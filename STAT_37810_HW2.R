source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/Likelihood.R")
source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/slopevalues.R")
source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/prior.R")
source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/posterior.R")
source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/proposalfunction.R")
source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/run_metropolis_MCMC.R")
source("E:/学习工作/硕士/software/github/local repository/assignment-2-boxinz17/MHsummary.R")

trueA <- 5  # set the true value of a to be 5
trueB <- 0  # set the true value of b to be 0
trueSd <- 10  # set the true value of sd to be 10
sampleSize <- 31  # set the sample size generated by model to be 31

# create independent x-values 
x <- (-(sampleSize-1)/2):((sampleSize-1)/2)  # set x as a arithmetic sequence from -15 to 15, the step is 1
# create dependent values according to ax + b + N(0,sd)
y <-  trueA * x + trueB + rnorm(n=sampleSize,mean=0,sd=trueSd)  # generate the sequence of y by model

plot(x,y, main="Test Data")  # plot the scatter plot for x and y

# Example: plot the likelihood profile of the slope a
slopelikelihoods <- lapply(seq(3, 7, by=.05), slopevalues )   # for a to be 3, 3.5, ..., 7, calculate the corresponding likelihood
plot (seq(3, 7, by=.05), slopelikelihoods , type="l", xlab = "values of slope parameter a", ylab = "Log likelihood")  # plot the line plot of a and corresponding likelihood value

######## Metropolis algorithm ################

startvalue = c(4,0,10)  # set the start value for our experiment
chain = run_metropolis_MCMC(startvalue, 10000)  # use the MH sampling function we defined to get the sample chain, the iteration times are setted as 10000

burnIn = 5000  # set the burn in time as 5000, that means we will drop the first 5000 samples because it may not converge
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))  # calculate the acceptance rate for our selected samples

### Summary: #######################

MHSummary(chain, burnIn, trueA, truB, trueSd)

# for comparison:
summary(lm(y~x))  # show the estimated coefficients using linear model for comparison

# comparison between different iteration numbers
compare_outcomes <- function(iteration.numbers){
  num.of.iteration <- length(iteration.numbers)  # record the number of different iteration times
  loop.num <- 10
  
  record.compare.mean <- array(dim=c(loop.num, num.of.iteration))
  record.compare.std <- array(dim=c(loop.num, num.of.iteration))
  
  for (i in c(1:loop.num)){
    startvalue <- c(1:3)
    startvalue[1] <- runif(n=1, min=0, max=10)
    startvalue[2] <- rnorm(n=1, sd = 5)
    startvalue[3] <- runif(n=1, min=0, max=30)
    
    print(paste("This is the", i, "loop"))
    
    for (j in c(1:num.of.iteration)){
      chain = run_metropolis_MCMC(startvalue, iteration.numbers[j])
      a.mean <- mean(chain[, 1])
      record.compare.mean[i, j] <- a.mean
      a.std <- sd(chain[, 1])
      record.compare.std[i, j] <- a.std
      print(paste("For iteration times as:", iteration.numbers[j], "the mean is:", a.mean, 
                  "The std is:", a.std))
    }
  }
  
  record.compare <- array(dim=c(loop.num, num.of.iteration))
  
  for (i in c(1:loop.num)){
    for (j in c(1:num.of.iteration)){
      record.compare[i, j] = paste("mean:", round(record.compare.mean[i, j], 3), 
                                   "std:", round(record.compare.std[i, j], 3))
    }
  }
  
  record.compare <- data.frame(record.compare)
  
  for (j in c(1:num.of.iteration)){
    colnames(record.compare)[j] <-  paste("iteration:", iteration.numbers[j])
  }
  
  for (j in c(1:num.of.iteration)){
    colnames(record.compare)[j] <-  paste("iteration:", iteration.numbers[j])
  }
  
  for (i in c(1:loop.num)){
    rownames(record.compare)[i] <- paste("loop ", i)
  }
  
  return(record.compare)
}

iteration.numbers <- c(1000, 10000, 100000)
m.compare.out <- compare_outcomes(iteration.numbers)
